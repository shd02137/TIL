# 20 카카오 인턴십 / 보석 쇼핑

## 첫번째 시도

```python
def solution(gems):

    gem_set = list(set(gems))
    # print(gem_set)
    length = len(gem_set)
    gem_on = dict()
    
    start = length + 1
    
    end = 0
    
    max_len = start
    
    answer = [start,end]
    for index,value in enumerate(gems,1):
        start = length + 1
        end = 0
        
        # print(index,value)
        
        if gem_on.get(value):
            gem_on[value] = index
        else:
            gem_on[value] = index
        # print(len(gem_on))
        if len(gem_on) == length:
            # print("now count")
            for i in gem_on:
                i = gem_on[i]
                if start > i:
                    start = i
                if end < i:
                    end = i
            # print(">",start,end)
            if max_len > end-start:
                max_len = end-start
                answer = [start,end]
    return answer
```

한참을 고민하다가 얼마전에 사용해봤던 투포인터 알고리즘을 적용시켜보았으나 최악의 경우 O(n^2)복잡도가 나왔고 시간초과가 나왔다. 다시 풀어보기로한다.



```python
def solution(gems):
    start = 0
    end = 1
    answer = [start+1,end]
    length = len(gems)
    shortest = length + 1
    total = len(set(gems))
    
    while end <= length:
        temp = gems[start:end]
        tem_length = len(set(temp))
        if tem_length != total:
            end += 1
            
        elif tem_length == total:
            temp_short = end- start
            # print(temp_short,start+1,end)
            if temp_short < shortest:
                shortest = temp_short
                answer = [start+1,end]
            start += 1
            
        # print(temp)
    
        
    return answer
```

좀더 적극적으로 투포인터를 사용했다. 답은 맞지만 효율성테스트를 실패해서 다시 풀기로 하였다.



---

