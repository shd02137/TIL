# OS 챕터4 - 스레드

[toc]

## 스레드

스레드는 CPU사용의 기본단위이다.(프로세스보다 더 작게 쪼개져서 cpu가 읽을수 있는 가장 작은 작업단위이다.)

스레드의 구성요소는 다음과 같다.

* Thread ID
* 프로그램 카운터
* 레지스터 세트
* 스택 스페이스

(프로세스의 구성요소는 __프로그램 카운터, 스택, 데이터영역__이다.)

스레드는 피어스레드와 아래의 요소를 공유한다.

* 코드 세션
* 데이터 세션
* OS 자원

전통적인 프로세스(혹은 한프로세스에 한스레드만 있는경우)에서는 한스레드로 모든 작업을 처리한다.

멀티 스레드 작업은 한작업이 블록 혹은 대기상태일때 다른 스래드에서 작업을 계속 할 수 있다.
한 작업에서 멀티 스레드 사이의 협력은 높은 성능의 향상을 기대할수 있다. 또한 공통버퍼를 공유하는 어플리케이션에서 스레드의 효율을 높일 수 있다. 

따라서 스레드는 다음과 같은 이득을 얻을 수 있다.

* 빠른 반응속도
* 자원 공유로 인한 경제성
* 멀티 프로세싱구조에서의 효율성



## 멀티플 프로세스 VS 멀티플 스레드

| 멀티플 프로세스                                              | 멀티플 스레드                                                |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 다른 프로세스에 대해 독립적으로 작동한다.                    | 다른 스레드에 대해 독립적이지 않다.                          |
| 구성 요소는 프로그램 카운터, 레지스터 세트, 스택 포인터이다. | 구성요소는 프로그램 카운터, 레지스터 세트, 스택 스페이스 이다. |
| 프로세스는 서로 같은 메모리를 공유하지 않는다.               | 스레드는 서로 같은 메모리를 사용할 수 있다.(콘텍스트 스위치를 위한 메모리 오버헤드 관리가 필요하지 않다.) |
| 프로세스는 다른 유저에 의해 생성 될수 있다.(상호 보호(Mutual Protection)이 필요하다.) | 단일 사용자만이 단일 작업에서 파생된 멀티플 스레드를 소유할수있다.(상호 보호가 불필요) |



## 유저 레벨 스레드 VS 커널 레벨 스레드



| 유저 레벨 스레드                                             | 커널 레벨 스레드                                             |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 커널을 사용하지 않는다.                                      | 커널을 사용한다.<br />인터럽트를 통해 커널 단위로 컨텍스트 스위칭을한다. |
| 유저레벨 스레드는 스위칭 할 때 <br />OS를 사용하지 않으므로 스위칭이 빠르다. | 스레드 스위칭에 시간이 더 걸린다.                            |
| 스케줄링이 불공평하다.<br />(커널이 오직 프로세스 단위로 스케쥴링 한다.) | 각각의 스레드가 독립적으로 스케쥴링 된다.                    |



### 유저 레벨 스레드

 스레드 관리는 API레벨에 있는 유저레벨 스레드 라이브러리에 의해 실행된다.
 유저 레벨의 스레드 관리법은 다음과 같다. 
 프로세스를 유저 레벨에서 스레드로 쪼갠다. (CPU는 kernel level thread만 보므로, 유저레벨에서 쪼갠 스레드는 실제 실행하는 대상이 아니다.) 여기서 만든 스레드를 커널에게 넘겨주면 넘겨진 작업을 CPU가 처리한다.



## 멀티 스레딩 모델

* Many to one

  많은 유저레벨의 스레드를 한개의 커널 스레드에 매핑힌다.

* One to one

  각각의 유저레벨 스레드가 커널 스레드 한개에 매핑된다.
  유저 레벨 스레드가 많아지면 커널스레드가 많아져야한다.

* Many to many

  여러개의 유저레벨 스레드를 여러개의 커널 스레드에 매핑 시킨다.
  OS가 충분한 수의 커널 스레드를 만들수 있도록 해야한다.

* Two level Model

  Many to Many 의 모델에 특정한 유저레벨 스레드와 바인딩 된 커널 스레드를 따로 만든 모델으로 중요한 작업이 밀려서 처리되는 것을 막아준다.



## 스레딩 이슈

### fork()와 exec()의 동작

fork()를 했을때 한개의 스레드만을 복사하는가? 모든 스레드를 복사하는가?

fork()를 실행한 스레드가  프로세스에 있는 많은 스레드 중 하나이면 exec()가 즉시 따라온다면 한개의 스레드만 복사를 하지만 exec()가 즉시 따라오지 않으면 모든 스레드를 복사한다.

### 스레드 취소

스레드가 종료되기 전에 삭제될 경우 두가지 접근방법이 존재한다.

* 스레드를 즉시 강제 종료한다.

  종료되는 스레드의 작업이 날아가고 자원을 반납하지 못하고 삭제된다.

* 스레드를 지연시켜 종료한다.

  지속적으로 스레드를 체크하여 스레드가 종료가 되었는지 확인한다.
  종료되는 스레드의 작업이 날아가지 않고 자원을 반납한뒤 삭제된다.

### 신호 핸들링

이벤트의 발생 유무를 어떻게 확인하는가?

* 전달된 신호를 해당하는 스레드(이벤트를 기다리는)에 보내준다.
* 전달된 신호를 프로세스의 모든 스레드에 보내준다.
* 전달된 신호를 프로세스의 전담 스레드에 보내준다.
* 모든 전달된 신호를 프로세스의 전담 스레드가 받아서 처리해 준다.



### 스레드 풀

미리 적당한 량의 스레드를 생성한 뒤 스레드에 넣어 작업 발생시 스레드 풀에서 빼서 사용한다.

이 경우 스레드 마다 별도의 데이터를 가질수 있게하는것이 효율적이다.



### 스케줄링

 Many to Many 혹은 Two level 모델은 모두 적절한 수의 커널 스레드를 유지하기 위해 통신을 할 필요가 있고, 이 통신을 통해 적절한 수의 커널 스레드를 유지할수 있다. (CPU-bound Vs IO-bound)
 스케듈러는 upcall이라는 것이 필요한데 upcall은 커널과 스레드 라이브러리 사이에서 통신하는 방법이다. 

* 스레드 라이브러리는 스레드를 생성하고 관리하기 위한 API를 제공하는 것이다.
  스레드 라이브러리를 생성하는 방법은 두가지가 있다.
  * 커널의 지원 없이 완전히 사용자 공간에만 라이브러리를 제공하는 것, 라이브러리를 위한 모든 코드와 자료구조는 사용자 공간에 존재한다. 라이브러리의 함수를 호출하는것은 시스템 호출이 아닌 사용자 공간의 지역 함수를 호출하게 된다.
  * 운영체제에 의해 지원되는 커널 수준의 라이브러리를 구현하는것으로 라이브러리를 위한 코드와 자료구조는 커널 공가네 존재한다. 라이브러릴 API를 호출하는 것은 커널 시스템 호출을 사용한다.

유저 레벨 스레드가 실제 커널 스레드에 들어가기위해서는 LWP를 거치게된다. 우선 LWP 에 들어갈 유저레벨 스레드가 되기 위해 경쟁을 한뒤 경쟁에서 이긴 스레드가 LWP에 들어가서 커널 스레드에 들어갈 수 있게 된다.
경량 프로세스(LWP)는 유저스레드 라이브러리를 위한 가상의 프로세서이다. 



### Pthreads

스레드의 생성과 동기화를 위해 만들어진 표준 API이다. API는 스레드 라이브러리의 행동을 결정지어줄 뿐 실행방법은 라이브러리의  개발에 달려있다.

* Window XP thread

  일대일 매핑을 구현한다.
  각각의 스레드는 다음을 가진다.

  * 스레드 아이디
  * 레지스터 세트

  * 분리된 유저와 커널 스택 
  * 스레드의 고유 데이터 저장공간

  (레지스터 세트와 스택, 고유 데이터 저장공간은 일반적인 스레드 콘텍스트와 같다.)

* Java thread

  자바의 스레드는 JVM으로 관리된다.

  자바의 스레드는 2가지 방식으로 생성된다.

  * 스레드 클래스의 extend 하여 새로운 클래스를 생성하고 run() 메소드를 오버라이드
  * runable 인터페이스를 구현하는 클래스를 정의하여 run()메소드를 구현하는것 

  