# OS 챕터2- 운영체제 구조

## 목표

* OS가 사용자와 프로세스 그리고 다른 시스템에 제공하는 서비스를 안다.
* OS의 구조를 다양하게 설명할수 있다.
* OS가 설치되고 어떻게 부팅 되는지 설명할 수 있다.



## OS 서비스

1. 사용자를 위한 서비스 프로그램

* 유저인터페이스  - 대부분의 OS는 UI(CLI,GUI,Batch)를 가지고있다. 

* 프로그램 실행 - 시스템은 프로그램을 메모리에 올리고 실행 할 수 있다.

* I/O 동작 - 프로그램 실행시 파일이나 I/O장치가 필요할 수 있다.

* 파일 시스템 관리 - 프로그램은 파일이나 폴더를 읽고 쓰고, 생성 삭제 탐색 정보 나열이 필요하다. 

* 통신 - 같은 컴퓨터 혹은 다른 컴퓨터 사이의 프로세스 사이에 정보교환이 필요하다.

* 에러 감지 - OS 는 가능한 에러들을 알고 에러가 발생하지 않도록 해야한다.

  

2. 프로그램을 효율적으로 실행하기 위한 서비스 프로그램

* 자원 할당 - 여러 사용자나 여러 작업이 동시에 일어날때, 자원은 각각에게 반드시 할당 되어야 한다.
* 회계(자원의 변동과 분석) - 어떤 일이 얼마나 자원을 사용하는 가 파악한다.
* 보안 - 컴퓨터 시스템에 대한 접근을 제어(Protection)하고 허가되지 않은 것을 거부(Security)한다.



## 시스템 콜

OS에 제공되는 서비스의 프로그래밍 인터페이스이다.

보통 C나 C++로 쓰여져있고, 직접 시스템콜을 사용하기보다 API를 통해 접근한다.

유명한 API 로는 Win32, POSIX API가 있다.

* 시스템콜은 보통 특정한 숫자로 연결되어있다. 시스템 콜 인터페이스는 이 슷자와 테이블을 이용해서 관리된다.
* 시스템 콜 인터페이스는 OS커널에 있는 시스템콜은 호출하고, 시스템의 상태나 어떠한 값은 반환해준다.
* 호출자는 시스템 인터페이스를 사용할때 어떠한 시스템 콜이 사용되는지 알 필요가 없다. 오직 API를 적절히 사용하고, OS가 어떤 결과를 줄지만 알면 된다.

### 시스템 콜의 파라마터 전달

* 일반적으로 3가지 방법이 사용된다.
  1.  가장 간단한 방법으로, 레지스터를 이용하여 파라미터가 전달 된다.
  2. 파라미터가 메모리에 테이블이나 블록 단위로 저장되어있다. 그리고 이 메모리의 주소가 레지스터를 이용하여 전달 된다. 이 방법은 리눅스나 솔라리스에서 사용된다.
  3. 파라미터가 프로그램에 의해 스택에 저장된다. 그리고 OS 시스템이 해당 스택에서 파라미터를 가져간다. 이경우 전달되는 파라미터는 길이에 제한이 없다.

### 시스템 콜의 종류

* 프로세스 컨트롤
* 파일 관리
* 디바이스 관리
* 정보 유지
* 통신



## 시스템 프로그램

시스템 프로그램은 프로그램의 개발과 실행을 편리하게 해준다.

* 파일 조작(파일 관리자)

  생성, 삭제, 복사, 이름변경, 프린트등 일반적인 파일 조작

* 상태정보 표시(시계,CPU 이용률)

  시간,가용 메모리, 메모리 크기, 사용자 수등 표시. 몇 시스템은 정보를 표현하기위해 레지스터리(레지스터의 묶음)를 구성한다.

* 파일내용 변경(에디터)

* 프로그래밍 언어지원(컴파일, 디버거)

* 프로그램 로딩과 실행(메모리에 loading)

  Absolute loader : 지정된 장소에 한번 올리면 변경 불가

  relocatable loader : 메모리의 위치를 바꿀수 있음

  linkable editor : 라이브러리를 호출할 때 로딩시키면서 연결시킴

  overlay-loader : 메모리에 필요한 부분부분을 덮어 쓰면서 메모리르 효율적으로 사용

* 통신 (컴퓨터와 컴퓨터, 컴퓨터와 사람,FTP등)

* 어플리케이션 프로그램

대부분의 유저가 보는 OS는 실제 시스템 콜이 아니라 시스템 프로그램에 의해 정의된 것이다.

### 시스템프로그램의 설계 원칙

* 사용자의 목표

  OS는 편리해야하고, 쉽고, 신뢰도가 높으며, 안전하고 빨라야한다.

* 시스템의 목표

  OS는 쉽게 설계, 유지보수가 가능해야하고 유연하고 에러가 없으며 효율적이어야 한다.

시스템 프로그램을 설계할때는 Policy와 Mechanism을 분리해서 설계해야한다.

Policy : ~가 필요하다.)
Mechanism : ~하게 구현한다.)

이 두가지가 분리 되어야 나중에 변동사항이 있을때 유연하게 대처가 가능하다.

## 레이어 구조

UNIX 가 이 방식으로 구성되어있다.

### 레이어 접근

OS 시스템은 높은 레이어부터 낮은 레이어까지 여러 레이어로 구분되어있다.
낮은 레이어는 하드웨어이고, 높은 레이어는 UI이다.
높은레이어에서 낮은 레이어는 사용이 가능하지만 낮은 레이어에서는 높은 레이어를 사용할 수 없다. 따라서 레이어를 정의할 때에는 신중하게 해야한다.



## 마이크로 커널 시스템 구조

많은 부분을 커널에서 사용자의 공간으로 이동시켰다.

컴퓨터가 항상 가지고 있어야하는 부분을 제외하고는 나머지는 모듈화 시켜서 필요할때 가져와서 사용한다.
이것들이 정보를 교환할 때에는 메시지 패싱을 사용한다. 

이것의 장점은 다음과 같다.

* 마이크로 커널을 확장하기 쉽다.
* 새로운 아키텍쳐에 OS를 넣기 쉽다.
* 신뢰성이 높고, 보안성이 높다.



### 모듈

대부분의 현대 OS 시스템은 커널 모듈을 사용한다.

특징은 다음과 같다.

* 객체지향을 사용한다.
* 모두 분리 시킬 수 있다.
* 메세지 패싱을 통해 각각의 인터페이스들이 통신을 한다.
* 각각은 커널에서 필요에 따라 로드할 수 있다.

대부분 레이어와 비슷하지만 훨신 유연하다.













































