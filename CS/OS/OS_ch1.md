# OS 챕터1 - 운영체제

## Bootstrap Program(부트스트랩 프로그램)

* 부트스트랩 프로그램은 전원을 키거나 재부팅을  할때 적재되는 프로그램이다.

* 보통 펌웨어라고 알려진 롬이나 EEPROM 에 위치한다.
* 시스템의 모든 요소를 초기화한다.
* 시작 실행파일과 시스템 커널을 로드한다.

Rom : 읽기 전용 메모리

EEPROM : 읽기 전용인데 특수하게 전기 신호를 줘서 내용을 바꿀수 있는 메모리



## 컴퓨터 시스템 작동

* 하나 이상의 CPU, 공유 메모리에 접근할수 있는 common bus를 통해 연결된 디바이스 컨트롤러의 연결한다.

* CPU와 디바이스들이 경쟁을 통해 메모리에 접근하며 작동한다.

* I/O와 디바이스는 병렬적으로 동작할 수 있다.

* 각각의 디바이스컨트롤러는 로컬버퍼를 가진다.

* CPU가 로컬버퍼와 메인 메모리 사이에서 데이터를 이동시킨다.

* I/O는 디바이스의 로컬버퍼에 데이터를 저장시킨다.

  (버퍼에 데이터를 가득 넣거나 동작이 종료되면 인터럽트를 발생시켜 cpu에 알려줌으로써, cpu가 데이터를 가져가도록 한다.)

  

## Interrupt

* 인터럽트 전송은 인터럽트 벡터에 의해 제어된다.

  인터럽트 벡터에서 어떤 인터럽트가 발생했는지 알아내고, 해결방법을 가져가서 해결한다. 

* 인터럽트 아키텍쳐에서는 반드시 인터럽트 된 명령어의 주소를 저장해야함 한다.

* 인터럽트 중 다른 인터럽트는 사용이 불가능하다. (인터럽트 손실을 막기 위해서)

* OS는 인터럽트에 의해 움직인다.

* 트랩 : 트랩은 에러나 사용자의 요청에 의해 소프트웨어에서 발생시키는 인터럽트이다.

  


### Interrupt Handling

* OS는 레지스터와 프로그램 카운터를 저장함으로써 CPU의 상태를 저장한다.

* 이후 어떤 종류의 인터럽트가 발생했는지 확인한다.

  Polling

   인터럽트를 걸었는지 하나씩 찾아가서 물어보며 해결한다.

  vectored interrupted system

   벡터 테이블을 보고 문제를 알아내서 해결방법을 찾아내어 해결한다.



## I/O Structure

* 동기식 I/O

  I/O가 시작되면, I/O가 끝날때까지 CPU는 IDLE하다.
  I/O가 진행되는 동안 계속해서 메로리에 접근하여 확인한다.

* 비동기식 I/O

  CPU는 I/O 디바이스에 I/O작업을 시키고 그 동안 다른 작업을 한다.
  CPU의 이용률을 높일 수 있어서 효율적이다. 
  대신 Device-Status Table 이 따로 필요하다.

  Device-Status Table은 I/O장치 각각에 대한 타입, 주소, 상태를 가지고 있다.



## DMA Structure (Direct Memory Access Structure)

* 높은 속도의 I/O 디바이스에서 메모리 속도에 가깝게 데이터 전송을 하기 위해 사용한다.
* 디바이스 컨트롤러는 CPU의 개입없이 버퍼 저장소에서 메인메모리로 데이터 블록을 직접 전송한다.
* 인터럽트는 생성된 한블럭마다 한번씩만 발생한다.

## Storage

### Storage Structure

* 메인 메모리는 CPU가 직접 접속할 수 있는 하나의 큰 저장소로 되어있다. 용량은 작다.

* 제 2 메모리(second memory)는 메인 메모리의 확장으로 약간 더 용량이 큰 비휘발성 저장소를 가진다. (EX> HDD)

* 자기 저장소는 자기로 데이터를 저장한다.

  디스크의 표면은 트랙으로 나누어지고, 트렉은 섹터로 나누어진다.
  
  

### Storage Hierachy

* 저장시스템은 몇몇 특징(속도, 비용, 휘발성)에 따라 계층으로 구성되어있다.

  > ` 앞에 있을수록 속도가 빠르고 비용이 비싸다. `
  >
  > 레지스터 -> 캐시 -> 메인 메모리 
  >
  > ` 이 위의 것들은 휘발성이 있다. `
  >
  > -> 전기디스크 -> 
  >
  > ` 이 위의 것들은 전기적으로 정보를 처리한다. `
  >
  > 자기 디스크 -> 광학 디스크 -> 자기 테이프

####  Cache(캐시)

  * 캐시는 두가지 의미가 있다.
    * 이름이 캐시인것 : 저장 장치의 이름이 캐시이다.
    * 역할이 캐시인것 : 모든 저장장치는 캐시의 역할이 가능하다. 느린 저장장치의 데이터를 가져와서 원할 때 더 빠른 속도로 주면 캐시의 역할을 할 수 있다.
* 캐시는 저장소의 크기보다 작다. 캐시관리는 중요한 문제로 캐시의 크기와 교환정책(쓸 확률이 높은 것을 가지고 있는 것)은 캐시의 히트율에 영향을 준다.
* 멀티 태스킹을 하는 환경에서는 가장 최근의 데이터를 사용하기 위해 항상 주의해야한다. 멀티프로세서 환경(CPU 가 여러개있는 환경)에서는 반드시 캐시 일관성(cache coherency) 문제가 발생한다. 
  이 문제를 해결하기 위해서는 별도의  메모리를 사용해서 변경사항이 있을경우 공지해주어 서로 갱신 해주면 해결이 가능하다.




## Operating System
### Operating System Structure(운영체제 구조)

* 멀티프로그래밍은 효율성이 요구된다.
  * 하나의 유저는 CPU와 I/O 디바이스를 항상 busy하게 유지할 수 없다.
  * 멀티프로그래밍은 작업을 관리하여 CPU가 항상 한개의 작업을 실행하도록 한다.
  * 전체 작업의 다른 작업들은 메모리에 저장되어있다.
  * 하나의 작업은 job scheduling을 통해 선택되고 실행된다.
  * I/O 작업을 통해 기다릴 때에는 다른 작업으로 교체된다.
* Timesharing(multitasking)은 다른 작업으로 계속하여 변경하며 사용자가 각각의 작업과 interact할수 있게 해주는 논리적인 확장 방법이다.
  * 반응시간은 1초 이하로 잡아야한다.
  * 메모리에 적정 수준의 프로세스만 올려좋아서 반응시간을 조절해야한다.
  * 가상 메모리는 메모리에 완전히 있지 않은 프로세스의 실행을 가능하게 해준다.
  * 

### Operating-system Operation(운영체제의 동작)

* 인터럽트는 하드웨어에 의해 동작한다.
* 소프트웨어의 에러나 요청으로 예외나 트랩이 발생한다.
* 다른 프로세스 문제들(무한 루프, 프로세스의 다른 프로세스나 OS 변경)을 막아야한다.
* 무한루프나 hogging resource(자원 차지)를 막기위해 타이머를 사용할 수 있다.
* 듀얼 모드를 이용하여 OS가 자기 자신이나 다른 시스템요소를 지킬수 있다.
  * 듀얼모드는 유저 모드와 커널 모드(운영체제 모드)가 있다.
  * Mode bit를 이용하여 두 모드중 어떤 모드를 사용하는것인지 구별할 수 있다.
  * 몇몇 기능은 특수하게 디자인되어 커널모드에서만 사용할 수 있다.
  * 시스템 콜을 이용하여 커널 모드와 유저모드 사이를 이동할 수 있다.



### Process Management(프로세스 관리)

프로세스는 실행중인 프로그램을 말한다.(프로그램은 수동적인 개체, 프로세스는 능동적인(실행되고 있는) 객체이다.)

* 프로세스가 작업을 완료하기 위해서는 자원이 요구된다.

  * CPU, 메모리, I/O, 파일들, 초기데이터

* 프로세스는 종료될때 사용하던 자원을 반납한다.

* 싱글 스레드(thread) 프로세스는 하나의 프로그램 카운터(PC)를 가지고있다.

  thread(스레드)는 process를 더 작은 단위로 쪼갠 일의 단위를 thread 라고 한다.

  PC(프로그램 카운터)는 다음으로 실행될 기능의 주소이다.

* 멀티 스레드 프로세스는 스레드 마다 한개의 프로그램 카운터를 가지고 있다.

  일반적으로 시스템은 많은 프로세스와 유저, OS가 하나(혹은 여러개)의 CPU에서 동시에 실행된다.

* 프로세스 관리를 위해 해야하는 것은 다음과 같다.

  * 유저와 시스템 프로세스들의 생성과 삭제

  * 프로세스의 중단과 재개

  * 프로세스 동기화를 위한 매커니즘

  * 프로세스사이의 커뮤니케이션을 위한 매커니즘

  * 데드락 핸들링을 위한 매커니즘

    데드락은 자원관리가 잘 안되어 생기는 현상으로 필요한 메모리가 부족할때 발생한다.

### Memory Management(메모리 관리)

* 메모리에 있는 모든 데이터가 프로세스에 사용되기 전후 메모리관리를 거쳐가야한다.
* 메모리에 있는 모든 명령어가 실행되기위해 메모리 관리를 거쳐가야한다.
* 메모리 관리는 메모리에 무엇이 언제있는지 결정한다. 이것으로 CPU의 응답시간과 사용률을 높일 수 있다.
* 메모리 관리의 활동은 다음과 같다.
  * 어느 공간을 누가 쓰는지 관리한다.
  * 어느 프로세스와 데이터를 메모리에 넣고 뺄지를 결정한다.
  * 메모리에 공간이 필요할때 무엇을 버리고 무엇을 가질지 결정한다.

### Storage Management(저장소 관리)

* 파일시스템 관리
  * 파일은 디렉토리고 관리된다.
  * 접근제어를 통해 누가 어디까지 접근할 수 있는지 결정한다.
  * 파일과 디렉토리를 생성하고 지운다.
  * 파일과 디렉토리를 조작하기위한 기본요소를 제공한다.
  * 어느파일이 어느 저장송에 있는지 관리한다.
  * 정보가 날아가지 않도록 비휘발성 저장소에 계속하여 백업한다.
* MassiveStorage Management 는 생략.



### I/O Subsystem

하드웨어의 특징을 사용자에게 숨기기 위해 필요하다. 

* I/O subsystem의 해아하는 일

  * 버퍼링, 캐싱, 스풀링을 이용해서 메모리를 관리한다.

    버퍼링은 전송될 데이터를 잠시 저장하는것이다.

    캐싱은 느린쪽의 데이터를 빠른 쪽의 데이터에 저장하는것이다.

    스풀링은 한작업의 출력을 다른 작업의 입력과 동시에 처리하는 것이다.



### Protection and Security

* 시스템은 유저가 누군지 알아낸 뒤 어디까지 할 수 있는지 결정한다.



## Computing Environment

* 클라이언트 서버 컴퓨팅
* Peer to Peer 컴퓨팅
* 웹기반 컴퓨팅
* 클라우드 컴퓨팅





